{"/":{"title":"🌱 Hayul's digital garden","content":"\n안녕하세요?  \n저의 개발 블로그, **'Hayul's digital garden'** 입니다.  \n아래 **Contents**를 통해 포스팅을 탐색할 수 있습니다. \n\n## Contents\n\n###  [👩‍💻 Coding Test](notes/coding-test.md)\n###  [📑 Paper Review](notes/paper-review.md)","lastmodified":"2022-10-09T15:40:29.188428991Z","tags":null},"/notes/%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C":{"title":"기능개발","content":"\n\u003e - 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.  \n\u003e - 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.  \n\u003e - 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 `return` 하도록 `solution` 함수를 완성하세요.  \n\n## 제한 사항\n\n-   작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.\n-   작업 진도는 100 미만의 자연수입니다.\n-   작업 속도는 100 이하의 자연수입니다.\n-   배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.\n\n## 입출력 예\n\n**입출력 예 #1**\n첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.\n\n따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.\n\n**입출력 예 #2**\n모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.\n\n따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.\n\n---\n\n## 풀이\n\n```python\ndef solution(progresses, speeds):\n    Q=[]\n    for p, s in zip(progresses, speeds):\n        if len(Q)==0 or Q[-1][0]\u003c-((p-100)//s):\n            Q.append([-((p-100)//s),1])\n        else:\n            Q[-1][1]+=1\n    return [q[1] for q in Q]\n```\n","lastmodified":"2022-10-09T15:40:29.192428956Z","tags":null},"/notes/%EB%8B%A4%EC%9D%8C-%ED%81%B0-%EC%88%AB%EC%9E%90":{"title":"다음 큰 숫자","content":"\n자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.\n\n-   조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.\n-   조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.\n-   조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.\n\n예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.\n\n**자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.**\n\n### 제한 사항\n\n-   n은 1,000,000 이하의 자연수 입니다.\n---\n\n### 입출력 예\n| n   | result |\n| --- | ------ |\n| 78  | 83     |\n| 15    |      23  |\n#### 입출력 예 설명\n- 입출력 예#1  \n\t- 문제 예시와 같습니다.  \n- 입출력 예#2  \n\t- 15(1111)의 다음 큰 숫자는 23(10111)입니다.\n--- \n\n## 좋은 풀이\n  \n```python\ndef solution(n):\n    num1 = bin(n).count('1')\n    while True:\n        n = n + 1\n        if num1 == bin(n).count('1'):\n            break\n    return n\n```\n  \n## 나의 풀이\n  \n```python\nfrom collections import Counter\n\ndef find_one(k):\n    return Counter(list(format(k, 'b')))['1']\n\ndef solution(n):\n    answer = n\n    while True:\n        answer += 1\n        if find_one(n) == find_one(answer):\n            break\n    return answer\n```\n   \n## 둘의 차이점\n우선 `Counter()`를 쓸 이유가 없었다. 왜냐하면 문자열 뒤에는` .count()`를 사용할 수 있기 때문이다. 굳이 `Counter()`를 쓰기 위해 리스트로 변환하는 작업도 필요가 없었던 것이다. 즉, 연산 낭비이다. 기억하자, 문자열에서 특정한 문자의 갯수를 알고 싶다면 `.count()`를 쓰면 된다는 것. ","lastmodified":"2022-10-09T15:40:29.192428956Z","tags":null},"/notes/%EC%88%AB%EC%9E%90-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%BC-%EC%98%81%EB%8B%A8%EC%96%B4":{"title":"숫자 문자열과 영단어","content":"## 문제 설명\n\n![img1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d31cb063-4025-4412-8cbc-6ac6909cf93e/img1.png)\n\n네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.  \n  \n다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.\n\n-   1478 → \"one4seveneight\"\n-   234567 → \"23four5six7\"\n-   10203 → \"1zerotwozero3\"\n\n이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 `s`가 매개변수로 주어집니다. `s`가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요.\n\n---\n\n##### 제한사항\n\n-   1 ≤ `s`의 길이 ≤ 50\n-   `s`가 \"zero\" 또는 \"0\"으로 시작하는 경우는 주어지지 않습니다.\n-   return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 `s`로 주어집니다.\n\n---\n\n##### 입출력 예\n\n| s                    | result      |\n| -------------------- | ----------- |\n| `\"one4seveneight\"`   | 1478        |\n| `\"23four5six7\"`      | 23four5six7 |\n| `\"2three45sixseven\"` | 234567      |\n|        `\"123\"`              |     123        |\n\n---\n\n##### 입출력 예 설명\n\n**입출력 예 #1**\n\n-   문제 예시와 같습니다.\n\n**입출력 예 #2**\n\n-   문제 예시와 같습니다.\n\n**입출력 예 #3**\n\n-   \"three\"는 3, \"six\"는 6, \"seven\"은 7에 대응되기 때문에 정답은 입출력 예 2와 같은 234567이 됩니다.\n-   입출력 예 2와 3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.\n\n**입출력 예 #4**\n\n-   `s`에는 영단어로 바뀐 부분이 없습니다.\n---\n\n##### 제한시간 안내\n\n-   정확성 테스트 : 10초\n\n***\n## 내 풀이\n```python\ndef solution(s):\n    result = ''\n    eng = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n    for idx, num in enumerate(eng):\n        if num in s:\n            s = s.replace(num, str(idx))\n        result = s\n            \n    return int(result)\n```\n\n`enumerate` 가 반환하는 인덱스와 영문 숫자가 일치해서 가능한 방법이었다.\n주어진 문자열에 해당 영문 숫자가 있는지 확인하고, 있다면 `replace`로 대체했다.\n이후 result를 계속 업데이트하고 최종적으로 `int`를 씌워서 반환하면 끝이다.","lastmodified":"2022-10-09T15:40:29.192428956Z","tags":null},"/notes/%EC%98%81%EC%96%B4-%EB%81%9D%EB%A7%90%EC%9E%87%EA%B8%B0":{"title":"영어 끝말잇기","content":"1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.\n\n1. 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.\n2. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.\n3. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.\n4. 이전에 등장했던 단어는 사용할 수 없습니다.\n5. 한 글자인 단어는 인정되지 않습니다.\n\n다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.\n\ntank → kick → know → wheel → land → dream → mother → robot → tank\n\n위 끝말잇기는 다음과 같이 진행됩니다.\n\n- 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.\n- 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.\n- 3번 사람이 자신의 첫 번째 차례에 know를 말합니다.\n- 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.\n- (계속 진행)\n\n끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.\n\n사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.\n\n#### 제한 사항\n\n- 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.\n- words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.\n- 단어의 길이는 2 이상 50 이하입니다.\n- 모든 단어는 알파벳 소문자로만 이루어져 있습니다.\n- 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.\n- 정답은 [ 번호, 차례 ] 형태로 return 해주세요.\n- 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.\n\n----\n\n#### 입출력 예\n\n| **n** | **words**                                                                                                                                                          | **result** |\n| ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------- |\n| 3     | [\"tank\", \"kick\", \"know\", \"wheel\", \"land\", \"dream\", \"mother\", \"robot\", \"tank\"]                                                                                      | [3,3]      |\n| 5     | [\"hello\", \"observe\", \"effect\", \"take\", \"either\", \"recognize\", \"encourage\", \"ensure\", \"establish\", \"hang\", \"gather\", \"refer\", \"reference\", \"estimate\", \"executive\"] | [0,0]      |\n| 2     | [\"hello\", \"one\", \"even\", \"never\", \"now\", \"world\", \"draw\"]                                                                                                          | [1,3]      |\n\n#### 입출력 예 설명\n\n입출력 예 #1\n\n3명의 사람이 끝말잇기에 참여하고 있습니다.\n\n- 1번 사람 : tank, wheel, mother\n- 2번 사람 : kick, land, robot\n- 3번 사람 : know, dream, `tank`\n\n와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 `tank`라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 `tank`와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다.\n\n입출력 예 #2\n\n5명의 사람이 끝말잇기에 참여하고 있습니다.\n\n- 1번 사람 : hello, recognize, gather\n- 2번 사람 : observe, encourage, refer\n- 3번 사람 : effect, ensure, reference\n- 4번 사람 : take, establish, estimate\n- 5번 사람 : either, hang, executive\n\n와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다.\n\n입출력 예 #3\n\n2명의 사람이 끝말잇기에 참여하고 있습니다.\n\n- 1번 사람 : hello, even, `now`, draw\n- 2번 사람 : one, never, world\n\n와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 'r'로 시작하는 단어 대신, n으로 시작하는 `now`를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다.\n\n---\n## 나의 풀이\n```python\ndef solution(n, words):\n    for p in range(1, len(words)):\n        if words[p-1][-1] != words[p][0] or words[p] in words[:p]:\n            return [(p%n) + 1, (p//n) + 1]\n    else:\n        return([0,0])\n```\n\n### 해석\n처음에는 단어와 사람 번호를 같이 딕셔너리에 저장하려고 했다. 그러나 계속 코드가 복잡해지자 생각을 바꾸고 위와 같이 코드를 새로 작성했다. 이 문제의 핵심은 두 가지이다.\n\n- **이전 단어의 마지막 글자와 현재 단어의 첫 글자가 일치하는가**\n- **이전에 나왔던 단어가 다시 나오는가**\n\n처음 것은 인덱스로 간단하게 확인하면 되는데, 두번째 것은 슬라이싱으로 확인하는 방법이 신선한 점이다. 결국 단어 리스트가 주어졌을 때, 현재 단어 이전에 똑같은 단어가 있는지만 확인하면 되는 것이므로. `LV-2` 이지만 짧게 해결할 수 있는 문제였다.","lastmodified":"2022-10-09T15:40:29.192428956Z","tags":null},"/notes/%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B4%84%ED%98%B8":{"title":"올바른 괄호","content":"# 올바른 괄호\n\n괄호가 바르게 짝지어졌다는 것은 '(' 문자로 열렸으면 반드시 짝지어서 ')' 문자로 닫혀야 한다는 뜻입니다. 예를 들어\n\n-   \"()()\" 또는 \"(())()\" 는 올바른 괄호입니다.\n-   \")()(\" 또는 \"(()(\" 는 올바르지 않은 괄호입니다.\n\n'(' 또는 ')' 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 `return` 하고, 올바르지 않은 괄호이면 false를 `return` 하는 `solution` 함수를 완성해 주세요.\n\n## 제한사항\n\n-   문자열 s의 길이 : 100,000 이하의 자연수\n-   문자열 s는 '(' 또는 ')' 로만 이루어져 있습니다.\n\n---\n## 입출력 예\n| s        | answer |\n| -------- | ------ |\n| \"()()\"   | true   |\n| \"(())()\" | true   |\n| \")()(\"   | false  |\n| \"(()(\"   | false  |\n\n---\n## 나의 코드\n```python\ndef solution(s):\n    answer = True\n    flag = 0\n    for n in s :\n        if flag \u003c 0 :\n            return False\n        if n == '(' :\n            flag += 1\n        else :\n            flag -= 1\n    return True if flag == 0 else False\n```\n\n\u003e [!note]\n\u003e 이 문제는 스택을 사용하는 문제이다. `flag` 용도로 쓸 변수를 선언하고 해당 변수를 이용하여 괄호가 올바른지를 체크했다. 만약에 `flag`가 음수가 되는 경우는 `)`가 먼저 나오는 경우라서 바로 올바르지 않기 때문에 `False`를 리턴했고, `(`이 나오는 경우는 `flag`를 증가시키고 `)`이 나오는 경우 `flag`를 감소시켜서 만약에 `0`이 되면 괄호가 열린만큼 닫힌거라 `True`를 리턴했고 `0`보다 크면 `(`가 더 많이 떴다는 뜻으로 `False`를 리턴했다.\n","lastmodified":"2022-10-09T15:40:29.192428956Z","tags":null},"/notes/%ED%82%A4%ED%8C%A8%EB%93%9C-%EB%88%84%EB%A5%B4%EA%B8%B0":{"title":"키패드 누르기","content":"\n스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다.\n\n![kakao_phone1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4b69a271-5f4a-4bf4-9ebf-6ebed5a02d8d/kakao_phone1.png)\n\n이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.  \n맨 처음 왼손 엄지손가락은 `*` 키패드에 오른손 엄지손가락은 `#` 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.\n\n1.  엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다.\n2.  왼쪽 열의 3개의 숫자 `1`, `4`, `7`을 입력할 때는 왼손 엄지손가락을 사용합니다.\n3.  오른쪽 열의 3개의 숫자 `3`, `6`, `9`를 입력할 때는 오른손 엄지손가락을 사용합니다.\n4.  가운데 열의 4개의 숫자 `2`, `5`, `8`, `0`을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.  \n    4-1. 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.\n\n순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요.\n\n## **[제한사항]**\n\n-   numbers 배열의 크기는 1 이상 1,000 이하입니다.\n-   numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다.\n-   hand는 `\"left\"` 또는 `\"right\"` 입니다.\n    -   `\"left\"`는 왼손잡이, `\"right\"`는 오른손잡이를 의미합니다.\n-   왼손 엄지손가락을 사용한 경우는 `L`, 오른손 엄지손가락을 사용한 경우는 `R`을 순서대로 이어붙여 문자열 형태로 return 해주세요.\n\n---\n\n### **입출력 예**\n\n| numbers                           | hand      | result          |\n| --------------------------------- | --------- | --------------- |\n| [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] | `\"right\"` | `\"LRLLLRLLRRL\"` |\n| [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] | `\"left\"`  | `\"LRLLRRLLLRR\"` |\n| [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]    | `\"right\"` | `\"LLRLLRLLRL\"`  |\n\n---\n## 나의 풀이\n```python\ndef solution(numbers, hand):\n    pad = {\n        1:(0,0), 2:(0,1), 3:(0,2),\n        4:(1,0), 5:(1,1), 6:(1,2),\n        7:(2,0), 8:(2,1), 9:(2,2),\n        '*':(3,0), 0:(3,1), '#':(3,2)\n    }\n    L_prev_key = pad['*']\n    R_prev_key = pad['#']\n    answer = ''\n\n    for key in numbers:\n        if key in [1,4,7]:\n            answer += 'L'\n            L_prev_key = pad[key]\n        elif key in [3,6,9]:\n            answer += 'R'\n            R_prev_key = pad[key]\n        else:\n            L_distance = abs(L_prev_key[0] - pad[key][0]) + abs(L_prev_key[1] - pad[key][1])\n            R_distance = abs(R_prev_key[0] - pad[key][0]) + abs(R_prev_key[1] - pad[key][1])\n            if L_distance \u003c R_distance:\n                answer += 'L'\n                L_prev_key = pad[key]\n            elif L_distance \u003e R_distance:\n                answer += 'R'\n                R_prev_key = pad[key]\n            else:\n                if hand == 'right':\n                    answer += 'R'\n                    R_prev_key = pad[key]\n                else:\n                    answer += 'L'\n                    L_prev_key = pad[key]\n    return answer\n```\n\n이 문제는 좌표가 필요한 문제이다. 좌표 튜플을 각 번호에 해당하는 딕셔너리에 저장하고 시작하면 된다. ","lastmodified":"2022-10-09T15:40:29.192428956Z","tags":null},"/notes/GLUCOSE":{"title":"GLUCOSE","content":"\n이 논문은 Elemental Cognition이라는 AI기업 연구자들이 여럿 참여하였으며 2020 EMNLP 컨퍼런스에서 Honourable Mention Papers에 오른 논문이다. Velog에 처음 포스팅하는 논문으로 이 논문을 정한 까닭은 **상식 추론 데이터셋** 을 상당히 흥미로운 방식으로 수집한 연구이기 때문이다. 인간의 인지 심리학에 영향을 받아 사건의 인과 관계를 10차원으로 정의하고, 이에 맞춰 상식 추론 데이터셋을 만들었다니...역시 EMNLP에는 아무나 투고하는 것이 아니다.  \n\n## Motivtion\n\n- 사람은 무언가를 읽거나 들을 때, **암시적인 상식 추론(implicit commonsense inferences)**을 만들어 무엇이 일어났고 왜 일어났는지를 이해한다.\n\n- 그러나 AI system은 reading comprehension이나 dialogue과 같은 태스크에 있어서 여전히 인간과 같은 상식 추론 능력을 보이지 못하고 있다.\n\n- 그 이유는...\n\n   - ‘상식(commonsense knowledge)’을 대규모로 휙득할 방법이 없기 때문에\n\n   - 그러한 지식들을 최신의 AI 시스템에 통합시킬 방법이 없기 때문에\n\n  \n## Claims\n\n\n- GlUCOSE 상식 추론 프레임워크를 통해 이러한 보틀넥을 해결할 수 있다.\n\n- GLUCOSE 데이터셋은 사건의 인과 설명을 10가지 차원을 제공하며, 또한 구체적인 스토리와 일반화된 법칙을 제공한다.\n\n\n## Significance\n\n\n- 암시적인 상식(Commonsense knowledge)를 대규모로 수집할 방법을 수립했다.\n\n- 기존의 사전학습 언어모델을 GLUCOSE에 훈련시키면 처음 보는 이야기에도 인간과 비슷한 정도의 상식 추론이 가능해진다.\n\n  \n## Introduction\n\n다음같은 상황을 가정해보자.\n\n  \n\n- 한 아이 앞에서 차가 방향을 틀었다.\n\n- 그 아이가 재빨리 자전거를 돌렸다.\n\n- 그 아이가 자전거에서 떨어졌다.\n\n- 그 아이의 무릎이 까졌다.\n\n  \n\n이 이야기를 읽으며 사람은 문장간의 **'인과 추론'** 을 만들어낼 수 있다. 예를 들어,\n\n  \n\n- '한 아이 앞에서 차가 방향을 틀었다.'\n\n- **그리고 그건** '그 아이가 재빨리 자전거를 돌렸다.'를 초래하고\n\n- **그리고 그건** '그 아이가 자전거에서 떨어졌다.' 를 초래하고\n\n- **그리고 그건** '그 아이의 무릎이 까졌다.'를 초래했다.\n\n  \n\n이러한 방식으로 말이다. **사람은 이처럼 어떻게 이야기 속 특정한 사건이 특정한 결과를 이끌었는지 묘사하는 '인과적 사슬'을 만들 수 있다**\n\n  \n\n그러나 AI system은 reading comprehension이나 dialogue과 같은 태스크에 있어서 여전히 인간과 같은 상식 추론 능력을 보이지 못하고 있다. 이는 두 가지 이유가 있는데, 첫째로 **암시적인 상식을 대규모로 획득할 길이 없으며**, 둘째로 그러한 지식을 **최신의 AI 시스템에 융합시킬 길이 없기** 때문이다.\n\n  \n\n이러한 상황을 해결하고 나온 것이 바로 GLUCOSE이다. GLUCOSE라는 이름도 바로 이 프레임워크가 AI를 위해 할 수 있는 기능을 비유적으로 보여주고 있는데, 사람의 지식 활동이 뇌 속의 글루코스 용량에 따라 좌우되는 것처럼, AI 시스템이 기본적 사고를 할 수 있도록 하는 연료가 되라는 의미에서 글루코스라고 지었다고 한다. 좋은 논문은 역시 이름도 잘 짓는다.\n\n  \n\n앞에서도 언급했지만, GLUCOSE 데이터는 아주 흥미로운 규칙으로 구축되었다. 논문의 표현을 가져오면 다음과 같다.\n  \n\n\u003e[!note]\n\u003e S라는 짧은 이야기의 X라는 선택된 문장이 주어지면, GLUCOSE는 X와 관련된, 인간의 인지 심리학에 영향을 받은 10가지 차원의 commonsense causal explanations을 정의한다.\n\n  \n뿐만 아니라, GLUCOSE는 commonsense knowledge를 세상에 관한 ‘미니 이론’이라고 할 수 있는 **‘반정형 추론 법칙(semi-structured inference rules)'** 의 형태로 인코딩하고, 각각은 구체적인 이야기에 근거한다는 특징도 있다.\n\n  \n\n이게 무슨 말일까? 다음 포스팅에서 계속해보자.","lastmodified":"2022-10-09T15:40:29.188428991Z","tags":null},"/notes/On-Cross-Dataset-Generalization-in-Automatic-Detection-of-Online-Abuse":{"title":"On Cross-Dataset Generalization in Automatic Detection of Online Abuse","content":"\u003e[!info] Reference\n\u003eNejadgholi, I., \u0026 Kiritchenko, S. (2020). On cross-dataset generalization in automatic detection of online abuse. _arXiv preprint arXiv:2010.07414_.\n\n## Research Questions\n\n\u003e Test and training sets were created for each dataset by performing a stratified split of 20% vs 80%, with the larger part used for training the models. The training sets were further subdivided, keeping 1/8 shares of them as separate validation sets during development and fine-tuning of the hyper-parameters.\n\n- Fine-tuning에서의 일반적인 방법을 말하고 있다. 전체 데이터를 label 분포를 유지한 채로 `train`, `test` 으로 나누고, 이후 `train`에서 `validation`을 다시 나눈다. 특히 `test` 데이터셋은 훈련에 쓰이지 않는데, 이후 학습한 모델의 일반화 성능을 평가할 때 사용한다. 그래서 `test` 데이터셋에서 성능이 잘 나온다면, 해당 모델이 다른 데이터셋에서도 성능이 잘 나올 것이라는 가설을 세울 수 있다.  \n- 그러나 본 논문은 이 가설에 의문을 제기한다. \n\n\u003e (...) the aim here, in contrast, was to see **how well the best models (that may have learnt some dataset-specific biases) performed on other datasets.** **This was done to investigate how well state-of-the-art systems perform in a real-life scenario**, i.e., when exposed to data from other domains, with the hypothesis that a model trained on one dataset that exhibits comparatively reasonable results on other datasets can be expected to generalise well.\n\n- 이 논문의 목적은 그렇게 한 데이터셋을 잘 학습한(아마도 그 데이터셋에 내재한 편향도 잘 학습한) 모델이 다른 데이터셋에 얼마나 성능이 좋은지 보는 것이다. 이건 실제 세계에서의 상황과 유사한데, 모델은 결국 다른 도메인에서 생성된 데이터에 노출될 수 밖에 없기 때문이다. \n- 이를 통해 *'한 데이터셋을 잘 학습하여 좋은 성능을 내는 모델이라면, 다른 데이터셋에도 잘 일반화를 할 수 있을 것*'이라는 가설을 실제로 확인해보는 것이다. \n\n\n## 실험 방법\n\n\u003e To explore how well the Toxic class from the Wiki-dataset generalizes to other types of offensive behaviour, **we train a binary classifier (Toxic vs. Normal) on the Wiki-dataset (combining the train, development and test sets) and test it on the Out-of-Domain Test set.** This classifier is expected to predict a positive (Toxic) label for the instances of classes Founta-Abusive, Founta-Hateful, Waseem-Sexism and Waseem-Racism, and a negative (Normal) label for the tweets in the Founta-Normal class. We fine-tune a BERT-based classifier (Devlin et al., 2019) with a linear prediction layer, the batch size of 16 and the learning rate of 2 × 10−5 for 2 epochs.\n\n- 저자들은 Wiki-dataset으로 훈련한 모델이 다른 데이터셋에 얼마나 잘 일반화하는가를 보기 위해, binary classifier를 wiki-Dataset으로 훈련시키고 *'도메인 외 테스트셋(the Out-of-Domain Test set)'* 에 이를 테스트 했다. 모델은 BERT를 사용했다.\n\n\n## 실험 결과\n\n![Table 3](notes/images/table3.png)\n\n\u003e Results: The overall performance of the classifier on the Out-of-Domain test set is quite high: weighted macro-averaged F1 = 0.90.\n- 저자들의 예상과 달리 전체적인 Out-of-Domain test 성능은 높은 편이었다. 그러나 Waseem 데이터셋의 Sexist, Racist class를 분류하는 데에는 Wiki-Dataset의 Toxic class로 훈련된 모델이 적합하지 않다는 사실을 확인했다. \n\n### Formulation에 대한 논의 \n#key-observation\n\u003e The impact of task formulation: From task formulations described in Section 3, observe that the Wiki-dataset defines the class Toxic in a general way. The class Founta-Abusive is also a general formulation of offensive behaviour. The similarity of these two definitions is reflected clearly in our results.\n- 흥미로운 분석은 Formulation에 대한 것이다. 먼저 Wiki dataset의 Tosic class에 대한 정의는 다음과 같다 : 'The class Toxic comprises rude, hateful, aggressive, disrespectful or unreasonable comments that are likely to make a person leave a conversation'.\n- 그런데 이것이, Waseem 데이터셋의 Sexist, Racist class를 분류하기에는 다소 일반적인 정의라는 것이다. \n---\n\n## Impact of Data Size on Generalizability\n#data-size\n\n\u003e Observe that the average accuracies remain unchanged when the dataset’s size triples at the same class balance ratio. This finding contrasts with the general assumption that more training data results in a higher classification performance.\n\n- 다음으로 저자는 또 흥미로운 포인트를 하나 더 확인했다. \n- 만약 class의 비율이 변하지 않는다면 데이터의 크기가 커지더라도 정확도(`accuracy`)는 변하지 않는다는 것이다. 이는 더 많은 훈련데이터가 항상 높은 분류 성능을 낸다는 general assumption과 반대되는 결과이다.\n\n## Discussion\n\n\u003e In the task of online abuse detection, both False Positive and False Negative errors can lead to significant harm as one threatens the freedom of speech and ruins people’s reputations, and the other ignores hurtful behaviour.\n- False Positive와 False Negative는 표현의 자유를 위협할 수 있다. \n\n\u003e We suggest evaluating each class (both positive and negative) separately taking into account the potential costs of different types of errors.\n- 그리고 저자들은 각 class를 따로 평가하는 것을 제안했다. ","lastmodified":"2022-10-09T15:40:29.188428991Z","tags":null},"/notes/coding-test":{"title":"👩‍💻 Coding Test","content":"## 프로그래머스 문제 모음\n\n### Level 1\n- [[notes/숫자 문자열과 영단어]]\n- [[notes/키패드 누르기]]\n\n### Level 2\n- [[notes/기능개발]]\n- [[notes/올바른 괄호]]\n- [[notes/다음 큰 숫자]]\n- [[notes/영어 끝말잇기]]\n","lastmodified":"2022-10-09T15:40:29.188428991Z","tags":null},"/notes/paper-review":{"title":"📑 Paper Review","content":"## Contents\n- [📄 GLUCOSE](notes/GLUCOSE.md)\n- [📄 On Cross-Dataset Generalization in Automatic Detection of Online Abuse](notes/On%20Cross-Dataset%20Generalization%20in%20Automatic%20Detection%20of%20Online%20Abuse.md)","lastmodified":"2022-10-09T15:40:29.192428956Z","tags":null}}