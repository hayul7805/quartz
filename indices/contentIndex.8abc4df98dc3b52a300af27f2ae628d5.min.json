{"/":{"title":"🌱 Hayul's digital garden","content":"\n안녕하세요?  \n저의 개발 블로그, **'Hayul's digital garden'** 입니다.  \n아래 **Contents**를 통해 포스팅을 탐색할 수 있습니다. \n\n## Contents\n\n###  [👩‍💻 Coding Test](notes/coding-test.md)\n###  [📑 Paper Review](notes/paper-review.md)\n### [⚙️ Algorithms](notes/Algorithms.md)","lastmodified":"2022-10-13T09:10:42.007571978Z","tags":null},"/notes/%EA%B5%AC%EB%AA%85%EB%B3%B4%ED%8A%B8":{"title":"구명보트","content":"무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 **2명**씩 밖에 탈 수 없고, 무게 제한도 있습니다.\n\n예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.\n\n구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.\n\n사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.\n\n## 제한사항\n\n-   무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.\n-   각 사람의 몸무게는 40kg 이상 240kg 이하입니다.\n-   구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.\n-   구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.\n\n## 입출력 예\n\n| people           | limit | return |\n| ---------------- | ----- | ------ |\n| [70, 50, 80, 50] | 100   | 3      |\n| [70, 80, 50]     | 100   | 3      |\n\n\n## 나의 풀이\n\n```python\ndef solution(people, limit) :\n    gone = 0\n    people.sort()\n\n    a = 0\n    b = len(people) - 1\n    \n    while a \u003c b :\n        if people[b] + people[a] \u003c= limit :\n            a += 1\n            gone += 1\n        b -= 1\n    \n    answer = len(people) - gone\n    \n    return answer\n```\n\n\u003e [!note] \n\u003e 이 문제에서 사용된  [Two Pointers](notes/Two%20Pointers.md) 알고리즘은 1차원 배열에서 두 개의 포인터를 조작하여 기존의 방식보다 빠르게 원하는 결과를 얻어내는 알고리즘이다.","lastmodified":"2022-10-13T09:10:42.01157202Z","tags":null},"/notes/%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C":{"title":"기능개발","content":"\n-  프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.  \n- 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.  \n- 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 `return` 하도록 `solution` 함수를 완성하세요.  \n\n## 제한 사항\n\n-   작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.\n-   작업 진도는 100 미만의 자연수입니다.\n-   작업 속도는 100 이하의 자연수입니다.\n-   배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.\n\n## 입출력 예\n\n**입출력 예 #1**\n첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.\n\n따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.\n\n**입출력 예 #2**\n모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.\n\n따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.\n\n## 풀이\n\n```python\ndef solution(progresses, speeds):\n    Q=[]\n    for p, s in zip(progresses, speeds):\n        if len(Q)==0 or Q[-1][0]\u003c-((p-100)//s):\n            Q.append([-((p-100)//s),1])\n        else:\n            Q[-1][1]+=1\n    return [q[1] for q in Q]\n```\n","lastmodified":"2022-10-13T09:10:42.01157202Z","tags":null},"/notes/%EB%8B%A4%EC%9D%8C-%ED%81%B0-%EC%88%AB%EC%9E%90":{"title":"다음 큰 숫자","content":"\n자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.\n\n-   조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.\n-   조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.\n-   조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.\n\n예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.\n\n**자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.**\n\n### 제한 사항\n-   n은 1,000,000 이하의 자연수 입니다.\n\n### 입출력 예\n| n   | result |\n| --- | ------ |\n| 78  | 83     |\n| 15    |      23  |\n#### 입출력 예 설명\n- 입출력 예#1  \n\t- 문제 예시와 같습니다.  \n- 입출력 예#2  \n\t- 15(1111)의 다음 큰 숫자는 23(10111)입니다.\n--- \n\n## 좋은 풀이\n  \n```python\ndef solution(n):\n    num1 = bin(n).count('1')\n    while True:\n        n = n + 1\n        if num1 == bin(n).count('1'):\n            break\n    return n\n```\n  \n## 나의 풀이\n  \n```python\nfrom collections import Counter\n\ndef find_one(k):\n    return Counter(list(format(k, 'b')))['1']\n\ndef solution(n):\n    answer = n\n    while True:\n        answer += 1\n        if find_one(n) == find_one(answer):\n            break\n    return answer\n```\n   \n## 둘의 차이점\n우선 `Counter()`를 쓸 이유가 없었다. 왜냐하면 문자열 뒤에는` .count()`를 사용할 수 있기 때문이다. 굳이 `Counter()`를 쓰기 위해 리스트로 변환하는 작업도 필요가 없었던 것이다. 즉, 연산 낭비이다. 기억하자, 문자열에서 특정한 문자의 갯수를 알고 싶다면 `.count()`를 쓰면 된다는 것. ","lastmodified":"2022-10-13T09:10:42.01157202Z","tags":null},"/notes/%EB%A9%80%EB%A6%AC%EB%9B%B0%EA%B8%B0":{"title":"멀리뛰기","content":"## 문제 설명\n\n효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는\n\n```\n(1칸, 1칸, 1칸, 1칸)  \n(1칸, 2칸, 1칸)  \n(1칸, 1칸, 2칸)  \n(2칸, 1칸, 1칸)  \n(2칸, 2칸)  \n```\n\n의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. \n\n**멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요.** \n\n예를 들어 4가 입력된다면, 5를 return하면 됩니다.\n\n**제한 사항**\n\n-   n은 1 이상, 2000 이하인 정수입니다.\n\n**입출력 예**\n\n| n   | result |\n| --- | ------ |\n| 4   | 5      |\n| 3   | 3      |\n\n**입출력 예 설명**\n\n입출력 예 #1  \n위에서 설명한 내용과 같습니다.\n\n입출력 예 #2\n\n(2칸, 1칸)  \n(1칸, 2칸)  \n(1칸, 1칸, 1칸)  \n\n총 3가지 방법으로 멀리 뛸 수 있습니다.\n\n## 문제 풀이\n\n이 문제는 [Dynamic Programming](notes/Dynamic%20Programming.md)을 이용하는 문제이다. `dp[n]` 은 `n`칸을 갈 수 있는 방법의 수이다. 그래서 `dp[1]`부터 `dp[n]`까지 경우의 수를 찾아 더해준다. 두 번째 for문에서는 1칸만으로 가는 경우의 수를 더해주고, 2칸도 사용해서 가는 경우의 수를 또 더해준다. \n\n결과적으로, 갈 수 있는 칸이 `[1,2]` 칸이기 때문에 `can-step`이 항상 `can-1` 또는 `can-2`가 되어 피보나치와 같아지게 된다. 이 코드는 만약 `[1,2]` 칸이 아니라 더 여러 개의 칸을 갈 수 있는 문제였어도 그대로 적용할 수 있다. \n\n피보나치로 푸는 코드는 다음과 같다.\n\n```python\ndef solution(n):\n    dp = [1] + [0] * n\n    dp[0], dp[1] = 1, 1\n    for i in range(2, n+1):\n        dp[i] = (dp[i-1] + dp[i-2]) % 1234567\n    return dp[n]\n```","lastmodified":"2022-10-13T09:10:42.01157202Z","tags":null},"/notes/%EC%88%AB%EC%9E%90-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%BC-%EC%98%81%EB%8B%A8%EC%96%B4":{"title":"숫자 문자열과 영단어","content":"\n![img1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d31cb063-4025-4412-8cbc-6ac6909cf93e/img1.png)\n\n네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.  \n  \n다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.\n\n-   1478 → \"one4seveneight\"\n-   234567 → \"23four5six7\"\n-   10203 → \"1zerotwozero3\"\n\n이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 `s`가 매개변수로 주어집니다. `s`가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요.\n\n---\n### 제한사항\n\n-   1 ≤ `s`의 길이 ≤ 50\n-   `s`가 \"zero\" 또는 \"0\"으로 시작하는 경우는 주어지지 않습니다.\n-   return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 `s`로 주어집니다.\n\n---\n### 입출력 예\n\n| s                    | result      |\n| -------------------- | ----------- |\n| `\"one4seveneight\"`   | 1478        |\n| `\"23four5six7\"`      | 23four5six7 |\n| `\"2three45sixseven\"` | 234567      |\n|        `\"123\"`              |     123        |\n\n---\n### 입출력 예 설명\n\n**입출력 예 #1**\n\n-   문제 예시와 같습니다.\n\n**입출력 예 #2**\n\n-   문제 예시와 같습니다.\n\n**입출력 예 #3**\n\n-   \"three\"는 3, \"six\"는 6, \"seven\"은 7에 대응되기 때문에 정답은 입출력 예 2와 같은 234567이 됩니다.\n-   입출력 예 2와 3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.\n\n**입출력 예 #4**\n\n-   `s`에는 영단어로 바뀐 부분이 없습니다.\n---\n### 제한시간 안내\n-   정확성 테스트 : 10초\n***\n\n## 내 풀이\n\n```python\ndef solution(s):\n    result = ''\n    eng = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n    for idx, num in enumerate(eng):\n        if num in s:\n            s = s.replace(num, str(idx))\n        result = s\n            \n    return int(result)\n```\n\n`enumerate` 가 반환하는 인덱스와 영문 숫자가 일치해서 가능한 방법이었다.\n주어진 문자열에 해당 영문 숫자가 있는지 확인하고, 있다면 `replace`로 대체했다.\n이후 result를 계속 업데이트하고 최종적으로 `int`를 씌워서 반환하면 끝이다.","lastmodified":"2022-10-13T09:10:42.01157202Z","tags":null},"/notes/%EC%98%81%EC%96%B4-%EB%81%9D%EB%A7%90%EC%9E%87%EA%B8%B0":{"title":"영어 끝말잇기","content":"\n1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.\n\n1. 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.\n2. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.\n3. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.\n4. 이전에 등장했던 단어는 사용할 수 없습니다.\n5. 한 글자인 단어는 인정되지 않습니다.\n\n다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.\n\ntank → kick → know → wheel → land → dream → mother → robot → tank\n\n위 끝말잇기는 다음과 같이 진행됩니다.\n\n- 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.\n- 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.\n- 3번 사람이 자신의 첫 번째 차례에 know를 말합니다.\n- 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.\n- (계속 진행)\n\n끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.\n\n사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.\n\n#### 제한 사항\n\n- 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.\n- words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.\n- 단어의 길이는 2 이상 50 이하입니다.\n- 모든 단어는 알파벳 소문자로만 이루어져 있습니다.\n- 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.\n- 정답은 [ 번호, 차례 ] 형태로 return 해주세요.\n- 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.\n\n----\n\n#### 입출력 예\n\n| **n** | **words**                                                                                                                                                          | **result** |\n| ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------- |\n| 3     | [\"tank\", \"kick\", \"know\", \"wheel\", \"land\", \"dream\", \"mother\", \"robot\", \"tank\"]                                                                                      | [3,3]      |\n| 5     | [\"hello\", \"observe\", \"effect\", \"take\", \"either\", \"recognize\", \"encourage\", \"ensure\", \"establish\", \"hang\", \"gather\", \"refer\", \"reference\", \"estimate\", \"executive\"] | [0,0]      |\n| 2     | [\"hello\", \"one\", \"even\", \"never\", \"now\", \"world\", \"draw\"]                                                                                                          | [1,3]      |\n\n#### 입출력 예 설명\n\n입출력 예 #1\n\n3명의 사람이 끝말잇기에 참여하고 있습니다.\n\n- 1번 사람 : tank, wheel, mother\n- 2번 사람 : kick, land, robot\n- 3번 사람 : know, dream, `tank`\n\n와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 `tank`라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 `tank`와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다.\n\n입출력 예 #2\n\n5명의 사람이 끝말잇기에 참여하고 있습니다.\n\n- 1번 사람 : hello, recognize, gather\n- 2번 사람 : observe, encourage, refer\n- 3번 사람 : effect, ensure, reference\n- 4번 사람 : take, establish, estimate\n- 5번 사람 : either, hang, executive\n\n와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다.\n\n입출력 예 #3\n\n2명의 사람이 끝말잇기에 참여하고 있습니다.\n\n- 1번 사람 : hello, even, `now`, draw\n- 2번 사람 : one, never, world\n\n와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 'r'로 시작하는 단어 대신, n으로 시작하는 `now`를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다.\n\n---\n\n## 나의 풀이\n\n```python\ndef solution(n, words):\n    for p in range(1, len(words)):\n        if words[p-1][-1] != words[p][0] or words[p] in words[:p]:\n            return [(p%n) + 1, (p//n) + 1]\n    else:\n        return([0,0])\n```\n\n### 해석\n처음에는 단어와 사람 번호를 같이 딕셔너리에 저장하려고 했다. 그러나 계속 코드가 복잡해지자 생각을 바꾸고 위와 같이 코드를 새로 작성했다. 이 문제의 핵심은 두 가지이다.\n\n- **이전 단어의 마지막 글자와 현재 단어의 첫 글자가 일치하는가**\n- **이전에 나왔던 단어가 다시 나오는가**\n\n처음 것은 인덱스로 간단하게 확인하면 되는데, 두번째 것은 슬라이싱으로 확인하는 방법이 신선한 점이다. 결국 단어 리스트가 주어졌을 때, 현재 단어 이전에 똑같은 단어가 있는지만 확인하면 되는 것이므로. `LV-2` 이지만 짧게 해결할 수 있는 문제였다.","lastmodified":"2022-10-13T09:10:42.01157202Z","tags":null},"/notes/%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B4%84%ED%98%B8":{"title":"올바른 괄호","content":"\n괄호가 바르게 짝지어졌다는 것은 '(' 문자로 열렸으면 반드시 짝지어서 ')' 문자로 닫혀야 한다는 뜻입니다. 예를 들어\n\n-   \"()()\" 또는 \"(())()\" 는 올바른 괄호입니다.\n-   \")()(\" 또는 \"(()(\" 는 올바르지 않은 괄호입니다.\n\n'(' 또는 ')' 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 `return` 하고, 올바르지 않은 괄호이면 false를 `return` 하는 `solution` 함수를 완성해 주세요.\n\n## 제한사항\n\n-   문자열 s의 길이 : 100,000 이하의 자연수\n-   문자열 s는 '(' 또는 ')' 로만 이루어져 있습니다.\n\n\n## 입출력 예\n| s        | answer |\n| -------- | ------ |\n| \"()()\"   | true   |\n| \"(())()\" | true   |\n| \")()(\"   | false  |\n| \"(()(\"   | false  |\n\n\n## 나의 풀이\n\n```python\ndef solution(s):\n    answer = True\n    flag = 0\n    for n in s :\n        if flag \u003c 0 :\n            return False\n        if n == '(' :\n            flag += 1\n        else :\n            flag -= 1\n    return True if flag == 0 else False\n```\n\n이 문제는 스택을 사용하는 문제이다. `flag` 용도로 쓸 변수를 선언하고 해당 변수를 이용하여 괄호가 올바른지를 체크했다. 만약에 `flag`가 음수가 되는 경우는 `)`가 먼저 나오는 경우라서 바로 올바르지 않기 때문에 `False`를 리턴했고, `(`이 나오는 경우는 `flag`를 증가시키고 `)`이 나오는 경우 `flag`를 감소시켜서 만약에 `0`이 되면 괄호가 열린만큼 닫힌거라 `True`를 리턴했고 `0`보다 크면 `(`가 더 많이 떴다는 뜻으로 `False`를 리턴했다.\n","lastmodified":"2022-10-13T09:10:42.01157202Z","tags":null},"/notes/%ED%82%A4%ED%8C%A8%EB%93%9C-%EB%88%84%EB%A5%B4%EA%B8%B0":{"title":"키패드 누르기","content":"\n스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다.\n\n![kakao_phone1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4b69a271-5f4a-4bf4-9ebf-6ebed5a02d8d/kakao_phone1.png)\n\n이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.  \n맨 처음 왼손 엄지손가락은 `*` 키패드에 오른손 엄지손가락은 `#` 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.\n\n1.  엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다.\n2.  왼쪽 열의 3개의 숫자 `1`, `4`, `7`을 입력할 때는 왼손 엄지손가락을 사용합니다.\n3.  오른쪽 열의 3개의 숫자 `3`, `6`, `9`를 입력할 때는 오른손 엄지손가락을 사용합니다.\n4.  가운데 열의 4개의 숫자 `2`, `5`, `8`, `0`을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.  \n    4-1. 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.\n\n순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요.\n\n## 제한사항\n\n-   numbers 배열의 크기는 1 이상 1,000 이하입니다.\n-   numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다.\n-   hand는 `\"left\"` 또는 `\"right\"` 입니다.\n    -   `\"left\"`는 왼손잡이, `\"right\"`는 오른손잡이를 의미합니다.\n-   왼손 엄지손가락을 사용한 경우는 `L`, 오른손 엄지손가락을 사용한 경우는 `R`을 순서대로 이어붙여 문자열 형태로 return 해주세요.\n\n## 입출력 예\n\n| numbers                           | hand      | result          |\n| --------------------------------- | --------- | --------------- |\n| [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] | `\"right\"` | `\"LRLLLRLLRRL\"` |\n| [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] | `\"left\"`  | `\"LRLLRRLLLRR\"` |\n| [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]    | `\"right\"` | `\"LLRLLRLLRL\"`  |\n\n## 나의 풀이\n\n```python\ndef solution(numbers, hand):\n    pad = {\n        1:(0,0), 2:(0,1), 3:(0,2),\n        4:(1,0), 5:(1,1), 6:(1,2),\n        7:(2,0), 8:(2,1), 9:(2,2),\n        '*':(3,0), 0:(3,1), '#':(3,2)\n    }\n    L_prev_key = pad['*']\n    R_prev_key = pad['#']\n    answer = ''\n\n    for key in numbers:\n        if key in [1,4,7]:\n            answer += 'L'\n            L_prev_key = pad[key]\n        elif key in [3,6,9]:\n            answer += 'R'\n            R_prev_key = pad[key]\n        else:\n            L_distance = abs(L_prev_key[0] - pad[key][0]) + abs(L_prev_key[1] - pad[key][1])\n            R_distance = abs(R_prev_key[0] - pad[key][0]) + abs(R_prev_key[1] - pad[key][1])\n            if L_distance \u003c R_distance:\n                answer += 'L'\n                L_prev_key = pad[key]\n            elif L_distance \u003e R_distance:\n                answer += 'R'\n                R_prev_key = pad[key]\n            else:\n                if hand == 'right':\n                    answer += 'R'\n                    R_prev_key = pad[key]\n                else:\n                    answer += 'L'\n                    L_prev_key = pad[key]\n    return answer\n```\n\n이 문제는 좌표가 필요한 문제이다. 좌표 튜플을 각 번호에 해당하는 딕셔너리에 저장하고 시작하면 된다. ","lastmodified":"2022-10-13T09:10:42.01157202Z","tags":null},"/notes/Algorithms":{"title":"⚙️ Algorithms","content":"- [⚙️ Two Pointers](notes/Two%20Pointers.md)\n- [⚙️ Dynamic Programming](notes/Dynamic%20Programming.md)","lastmodified":"2022-10-13T09:10:42.007571978Z","tags":null},"/notes/Call-for-Customized-Conversation":{"title":"Call for Customized Conversation-Customized Conversation Grounding Persona and Knowledge","content":"\n## Abstarct\n\u003e Humans usually have conversations by making use of prior knowledge about a topic and background information of the people whom they are talking to. **However, existing conversational agents and datasets do not consider such comprehensive information, and thus they have a limitation in generating the utterances where the knowledge and persona are fused properly.** To address this issue, we introduce a call For Customized conversation **(FoCus) dataset** where the customized answers are built with the user’s persona and Wikipedia knowledge. (...)\n- 현재 상황과 한계를 찾아보자. \n\t- 사람은 대화의 주제나, 자기와 말하고 있는 사람의 배경 정보 등에 기대어 대화를 이어나간다. 그러나 현재 대화 시스템이나 데이터셋은 이러한 정보들을 이해하지 못하고 있으며, 따라서 지식이나 성격이 함께 적절히 융합된 발화를 생성하는 데에 한계가 있다. \n- 그래서 본 논문의 목적은?\n\t- 이에 본 논문은 이용자의 성격(persona)와 Wikipedia과 함께 구축된 FoCus 데이터셋을 발표했다.\n\n\u003e We examine whether the model reflects adequate persona and knowledge with our proposed two sub-tasks, **persona grounding (PG) and knowledge grounding (KG)**.\n- 그래서 그걸로 뭘 한 건데?\n\t- 모델이 적절히 페르소나와 지식을 반영하는지 확인해볼 것이다. \n\t- `Persona grounding (PG)` 와 `Knowledge grounding (KG)`라고 하는 서브 태스크를 통해서!\n\n## FoCus Dataset\n\n![Figure 2: Example dialog between Human and Machine in FoCus dataset](Example-dialog.png)\n- 그래서 이런 대화가 가능하도록 하고 싶다는 것이다. \n- 이용자와 대화를 진행하는 시스템이 실제 지식에 기반하면서('This place is called Sentosa'), 또한 이용자의 페르소나에 근거하여 말을 이어나가는 것('I believe you wish to visit Singapore.')!\n\n## Model\n\n![](Overview-of-model.png)\n\u003e We introduce the baseline models trained on our FoCus dataset, consisting of a `retrieval module` and a `dialog module`. The `retrieval module` retrieves the knowledge paragraphs related to a question, and the `dialog module` generates utterances of the machine by taking the retrieved knowledge paragraphs, human’s persona, and previous utterances as inputs.\n- 그래서 모델 아키텍쳐에는 두 개의 모듈이 들어간다. `retrieval module` 과 `dialog module` 이다. `retrieval module` 은 질문과 관련된 지식 파라그래프를 검색하고, `dialog module` 은 이것과 이용자의 페르소나 정보에 근거해서 모델의 발화를 생성해내는 것이다.\n\n![Table 3: Experimental results](Experimental-results.png)\n- 실험 결과, PG, KG에 모두 훈련된 BART와 GPT-2가 generation에서는 조금 성능이 낮지만 전반적으로 비슷한 성능을 보여주며, Grouding 서브 태스크에서는 가장 뛰어난 성능을 보여주었다. \n\n## Conclusion\n\u003e We hope that the researches aim to make dialog agents more attractive and knowledgeable with grounding abilities to be explored.\n- 우리는 연구자들이 더 있을 실제적 능력들과 함께, 대화 에이전트를 더욱 매력적이고 지식을 풍부히 가지도록 만드는 것을 목적으로 하기를 희망한다. \n- 끝맺음은 훈훈하게 하는구나. 대화 시스템은 더욱 매력적이게 될 수 있다. **감정 뿐만 아니라 지식, 페르소나를 모두 고려한 대화 시스템은 어떤 모습이 될까?**","lastmodified":"2022-10-13T09:10:42.007571978Z","tags":null},"/notes/Dynamic-Programming":{"title":"Algorithm - Dynamic Programming","content":"\n\u003e 이번 포스팅에서는 _\"한 번 계산한 문제는 다시 계산하지 않도록 한다!\"_ 는 **다이나믹 프로그래밍(Dynamic Programming, 동적 계획법이라고도 함)**에 대해서 소개해보고 이를 Python으로 구현하는 방법에 대해 알아보자.\n\n\n다이나믹 프로그래밍은 **메모리 공간을 약간 더 사용**해서 연산 속도를 비약적으로 증가시키는 방법이다. 우선 다음과 같은 2가지 조건을 만족할 때 다이나믹 프로그래밍을 사용할 수 있다.\n\n1.  **큰 문제를 작은 문제로 나눌 수 있다.**\n2.  **작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일**하다.\n\n위 조건을 만족하는 대표적인 문제가 **피보나치 수열** 문제이다. 피보나치 수열은 다음과 같은 점화식을 만족하는 수열이다.\n\n$$\na_n=a_{n−1} + a_{n−2} ,\\ a_1=1 ,\\ a_2=1\n$$\n\n다이나믹 프로그래밍의 포인트는 바로 한 번 결과를 수행한 것을 메모리에 저장해 놓고 다음에 똑같은 결과가 필요하면 그 때 다시 연산하지 않고 메모리에 저장된 그 값을 가져와 쓰는 것이다.\n\n이러한 것을 **메모제이션(캐싱) 기법**이라고도 한다. 다음은 **재귀함수**를 사용한 다이나믹 프로그래밍으로 피보나치 수열을 구현한 코드이다.\n\n```python\nimport time\n\ndp = [0] * 50\n\ndef fibo(x):\n    if x == 1 or x == 2:\n        return 1\n    if dp[x] != 0:\n        return dp[x]\n    dp[x] = fibo(x-1) + fibo(x-2)\n    return dp[x]\n\nfor num in range(5, 40, 10):\n    start = time.time()\n    res = fibo(num)\n    print(res, '-\u003e 러닝타임:', round(time.time() - start, 2), '초')\n```\n\n이렇게 재귀함수를 사용해 구현하는 다이나믹 프로그래밍 방법은 메모제이션 기법을 활용한 `Top-Down` 방식이라고 한다.\n\n즉, 큰 문제를 해결하기 위해 작은 문제를 호출하는 것이다. \n\n반면에 재귀함수를 사용하지 않고 **단순 반복문**을 사용해 다이나믹 프로그래밍을 구현할 수 있다. 하단의 코드를 살펴보자.\n\n```python\ndp = [0] * 100\n\ndp[1] = 1 # 첫 번째 항\ndp[2] = 1 # 두 번째 항\nN = 99   # 피보나치 수열의 99번째 숫자는?\n\nfor i in range(3, N+1):\n    dp[i] = dp[i-1] + dp[i-2]\n\nprint(dp[N])\n```\n\n위와 같은 방식은 작은 문제부터 차근차근 답을 도출해서 큰 문제를 해결한다고 하여 `Bottom-Up` 방식이라고 한다. 참고로 Top-Down 방식에서는 이미 수행한 결과를 저장하는 것을 `메모제이션`, Bottom-Up 방식에서는 `DP 테이블`이라고 한다.\n\n일반적으론 단순 반복문을 활용하는 **Bottom-Up 방식으로 다이나믹 프로그래밍 방법을 해결**하라고 권장한다. 만약 재귀함수를 사용하는 Top-Down 방식을 사용하다 보면 재귀 횟수 제한 오류가 걸릴 수도 있기 때문이다.","lastmodified":"2022-10-13T09:10:42.007571978Z","tags":null},"/notes/GLUCOSE":{"title":"GLUCOSE: GeneraLized and COntextualized Story Explanations","content":"\u003e[!info] Reference\n\u003eNasrin Mostafazadeh, Aditya Kalyanpur, Lori Moon, David Buchanan, Lauren Berkowitz, Or Biran, and Jennifer Chu-Carroll. 2020. [GLUCOSE: GeneraLized and COntextualized Story Explanations](https://aclanthology.org/2020.emnlp-main.370). In _Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP)_, pages 4569–4586, Online. Association for Computational Linguistics.\n\n이 논문은 Elemental Cognition이라는 AI기업 연구자들이 여럿 참여하였으며 2020 EMNLP 컨퍼런스에서 Honourable Mention Papers에 오른 논문이다. 블로그에 처음 포스팅하는 논문으로 이 논문을 정한 까닭은 **상식 추론 데이터셋** 을 상당히 흥미로운 방식으로 수집한 연구이기 때문이다. 인간의 인지 심리학에 영향을 받아 사건의 인과 관계를 10차원으로 정의하고, 이에 맞춰 상식 추론 데이터셋을 만들었다니...역시 EMNLP에는 아무나 투고하는 것이 아니다.  \n\n## Motivtion\n- 사람은 무언가를 읽거나 들을 때, **암시적인 상식 추론(implicit commonsense inferences)**을 만들어 무엇이 일어났고 왜 일어났는지를 이해한다.\n- 그러나 AI system은 reading comprehension이나 dialogue과 같은 태스크에 있어서 여전히 인간과 같은 상식 추론 능력을 보이지 못하고 있다.\n- 그 이유는...\n\t- ‘상식(commonsense knowledge)’을 대규모로 휙득할 방법이 없기 때문에\n\t- 그러한 지식들을 최신의 AI 시스템에 통합시킬 방법이 없기 때문에\n\n## Claims\n- GlUCOSE 상식 추론 프레임워크를 통해 이러한 보틀넥을 해결할 수 있다.\n- GLUCOSE 데이터셋은 사건의 인과 설명을 10가지 차원을 제공하며, 또한 구체적인 스토리와 일반화된 법칙을 제공한다.\n\n## Significance\n- 암시적인 상식(Commonsense knowledge)를 대규모로 수집할 방법을 수립했다.\n- 기존의 사전학습 언어모델을 GLUCOSE에 훈련시키면 처음 보는 이야기에도 인간과 비슷한 정도의 상식 추론이 가능해진다.\n\n  \n## Introduction\n\n다음같은 상황을 가정해보자.\n\n- 한 아이 앞에서 차가 방향을 틀었다.\n- 그 아이가 재빨리 자전거를 돌렸다.\n- 그 아이가 자전거에서 떨어졌다.\n- 그 아이의 무릎이 까졌다.\n\n이 이야기를 읽으며 사람은 문장간의 **'인과 추론'** 을 만들어낼 수 있다. 예를 들어,\n\n- '한 아이 앞에서 차가 방향을 틀었다.'\n- **그리고 그건** '그 아이가 재빨리 자전거를 돌렸다.'를 초래하고\n- **그리고 그건** '그 아이가 자전거에서 떨어졌다.' 를 초래하고\n- **그리고 그건** '그 아이의 무릎이 까졌다.'를 초래했다.\n\n이러한 방식으로 말이다. **사람은 이처럼 어떻게 이야기 속 특정한 사건이 특정한 결과를 이끌었는지 묘사하는 '인과적 사슬'을 만들 수 있다**\n\n그러나 AI system은 reading comprehension이나 dialogue과 같은 태스크에 있어서 여전히 인간과 같은 상식 추론 능력을 보이지 못하고 있다. 이는 두 가지 이유가 있는데, 첫째로 **암시적인 상식을 대규모로 획득할 길이 없으며**, 둘째로 그러한 지식을 **최신의 AI 시스템에 융합시킬 길이 없기** 때문이다.\n\n이러한 상황을 해결하고 나온 것이 바로 GLUCOSE이다. GLUCOSE라는 이름도 바로 이 프레임워크가 AI를 위해 할 수 있는 기능을 비유적으로 보여주고 있는데, 사람의 지식 활동이 뇌 속의 글루코스 용량에 따라 좌우되는 것처럼, AI 시스템이 기본적 사고를 할 수 있도록 하는 연료가 되라는 의미에서 글루코스라고 지었다고 한다. 좋은 논문은 역시 이름도 잘 짓는다.\n\n앞에서도 언급했지만, GLUCOSE 데이터는 아주 흥미로운 규칙으로 구축되었다. 논문의 표현을 가져오면 다음과 같다.\n  \n\u003e S라는 짧은 이야기의 X라는 선택된 문장이 주어지면, GLUCOSE는 X와 관련된, 인간의 인지 심리학에 영향을 받은 10가지 차원의 commonsense causal explanations을 정의한다.\n\n뿐만 아니라, GLUCOSE는 commonsense knowledge를 세상에 관한 ‘미니 이론’이라고 할 수 있는 **‘반정형 추론 법칙(semi-structured inference rules)'** 의 형태로 인코딩하고, 각각은 구체적인 이야기에 근거한다는 특징도 있다.","lastmodified":"2022-10-13T09:10:42.007571978Z","tags":null},"/notes/On-Cross-Dataset-Generalization-in-Automatic-Detection-of-Online-Abuse":{"title":"On Cross-Dataset Generalization in Automatic Detection of Online Abuse","content":"\u003e[!info] Reference\n\u003eNejadgholi, I., \u0026 Kiritchenko, S. (2020). On cross-dataset generalization in automatic detection of online abuse. _arXiv preprint arXiv:2010.07414_.\n\n## Research Questions\n\n\u003e Test and training sets were created for each dataset by performing a stratified split of 20% vs 80%, with the larger part used for training the models. The training sets were further subdivided, keeping 1/8 shares of them as separate validation sets during development and fine-tuning of the hyper-parameters.\n\n- Fine-tuning에서의 일반적인 방법을 말하고 있다. 전체 데이터를 label 분포를 유지한 채로 `train`, `test` 으로 나누고, 이후 `train`에서 `validation`을 다시 나눈다. 특히 `test` 데이터셋은 훈련에 쓰이지 않는데, 이후 학습한 모델의 일반화 성능을 평가할 때 사용한다. 그래서 `test` 데이터셋에서 성능이 잘 나온다면, 해당 모델이 다른 데이터셋에서도 성능이 잘 나올 것이라는 가설을 세울 수 있다.  \n- 그러나 본 논문은 이 가설에 의문을 제기한다. \n\n\u003e (...) the aim here, in contrast, was to see **how well the best models (that may have learnt some dataset-specific biases) performed on other datasets.** **This was done to investigate how well state-of-the-art systems perform in a real-life scenario**, i.e., when exposed to data from other domains, with the hypothesis that a model trained on one dataset that exhibits comparatively reasonable results on other datasets can be expected to generalise well.\n\n- 이 논문의 목적은 그렇게 한 데이터셋을 잘 학습한(아마도 그 데이터셋에 내재한 편향도 잘 학습한) 모델이 다른 데이터셋에 얼마나 성능이 좋은지 보는 것이다. 이건 실제 세계에서의 상황과 유사한데, 모델은 결국 다른 도메인에서 생성된 데이터에 노출될 수 밖에 없기 때문이다. \n- 이를 통해 *'한 데이터셋을 잘 학습하여 좋은 성능을 내는 모델이라면, 다른 데이터셋에도 잘 일반화를 할 수 있을 것*'이라는 가설을 실제로 확인해보는 것이다. \n\n\n## 실험 방법\n\n\u003e To explore how well the Toxic class from the Wiki-dataset generalizes to other types of offensive behaviour, **we train a binary classifier (Toxic vs. Normal) on the Wiki-dataset (combining the train, development and test sets) and test it on the Out-of-Domain Test set.** This classifier is expected to predict a positive (Toxic) label for the instances of classes Founta-Abusive, Founta-Hateful, Waseem-Sexism and Waseem-Racism, and a negative (Normal) label for the tweets in the Founta-Normal class. We fine-tune a BERT-based classifier (Devlin et al., 2019) with a linear prediction layer, the batch size of 16 and the learning rate of 2 × 10−5 for 2 epochs.\n\n- 저자들은 Wiki-dataset으로 훈련한 모델이 다른 데이터셋에 얼마나 잘 일반화하는가를 보기 위해, binary classifier를 wiki-Dataset으로 훈련시키고 *'도메인 외 테스트셋(the Out-of-Domain Test set)'* 에 이를 테스트 했다. 모델은 BERT를 사용했다.\n\n\n## 실험 결과\n\n![Table 3](notes/images/table3.png)\n\n\u003e Results: The overall performance of the classifier on the Out-of-Domain test set is quite high: weighted macro-averaged F1 = 0.90.\n- 저자들의 예상과 달리 전체적인 Out-of-Domain test 성능은 높은 편이었다. 그러나 Waseem 데이터셋의 Sexist, Racist class를 분류하는 데에는 Wiki-Dataset의 Toxic class로 훈련된 모델이 적합하지 않다는 사실을 확인했다. \n\n### Formulation에 대한 논의 \n#key-observation\n\u003e The impact of task formulation: From task formulations described in Section 3, observe that the Wiki-dataset defines the class Toxic in a general way. The class Founta-Abusive is also a general formulation of offensive behaviour. The similarity of these two definitions is reflected clearly in our results.\n- 흥미로운 분석은 Formulation에 대한 것이다. 먼저 Wiki dataset의 Tosic class에 대한 정의는 다음과 같다 : 'The class Toxic comprises rude, hateful, aggressive, disrespectful or unreasonable comments that are likely to make a person leave a conversation'.\n- 그런데 이것이, Waseem 데이터셋의 Sexist, Racist class를 분류하기에는 다소 일반적인 정의라는 것이다. \n\n## Impact of Data Size on Generalizability\n#data-size\n\n\u003e Observe that the average accuracies remain unchanged when the dataset’s size triples at the same class balance ratio. This finding contrasts with the general assumption that more training data results in a higher classification performance.\n\n- 다음으로 저자는 또 흥미로운 포인트를 하나 더 확인했다. \n- 만약 class의 비율이 변하지 않는다면 데이터의 크기가 커지더라도 정확도(`accuracy`)는 변하지 않는다는 것이다. 이는 더 많은 훈련데이터가 항상 높은 분류 성능을 낸다는 general assumption과 반대되는 결과이다.\n\n## Discussion\n\n\u003e In the task of online abuse detection, both False Positive and False Negative errors can lead to significant harm as one threatens the freedom of speech and ruins people’s reputations, and the other ignores hurtful behaviour.\n- False Positive와 False Negative는 표현의 자유를 위협할 수 있다. \n\n\u003e We suggest evaluating each class (both positive and negative) separately taking into account the potential costs of different types of errors.\n- 그리고 저자들은 각 class를 따로 평가하는 것을 제안했다. ","lastmodified":"2022-10-13T09:10:42.007571978Z","tags":null},"/notes/Towards-generalisable-hate-speech-detection":{"title":"Towards generalisable hate speech detection","content":"\u003e [!info] Reference\n\u003e Yin, W., \u0026 Zubiaga, A. (2021). Towards generalisable hate speech detection: a review on obstacles and solutions. _PeerJ Computer Science_, _7_, e598.\n\n## Data\n\n\u003e [예시 1]\n\u003e For example, in Wiegand, Ruppenhofer \u0026 Kleinbauer (2019)’s study, FastText models (Joulin et al., 2017a) trained on three datasets (Kaggle, Founta, Razavi) achieved F1 scores above 70 when tested on one another, **while models trained or tested on datasets outside this group achieved around 60 or less**.\n- 다른 데이터셋에서는 모델의 성능이 떨어진다는 결과가 있다.\n\n#key-observation \n\u003e Founta and OLID produced models that performed well on each other. The source of such differences are usually traced back to search terms (Swamy, Jamatia \u0026 Gambäck, 2019), topics covered (Nejadgholi \u0026 Kiritchenko, 2020; Pamungkas, Basile \u0026 Patti, 2020), label definitions (Pamungkas \u0026 Patti, 2019; Pamungkas, Basile \u0026 Patti, 2020; Fortuna, Soler-Company \u0026 Wanner, 2021), and data source platforms (Glavaš, Karan \u0026 Vulić, 2020; Karan \u0026 Šnajder, 2018).\n- 서로 테스트 성능이 잘 나오는 데이터셋은 그 근원을 따라가보면 알 수 있는 사실이 있다. 예를 들면, Founta와 OLID 데이터셋은 서로 비슷한 데이터를 공유하고 있다. \n\n\u003e Another way of looking at generalisation and similarity is by comparing differences between individual classes across datasets (Nejadgholi \u0026 Kiritchenko, 2020; Fortuna, Soler \u0026 Wanner, 2020; Fortuna, Soler-Company \u0026 Wanner, 2021), as opposed to comparing datasets as a whole.\n- 이 논문에서도 class 개별로 비교하라고 주장하는구나. [On Cross-Dataset Generalization in Automatic Detection of Online Abuse](notes/On%20Cross-Dataset%20Generalization%20in%20Automatic%20Detection%20of%20Online%20Abuse.md) 에서 주장하는 것과 맞물린다. \n\n","lastmodified":"2022-10-13T09:10:42.007571978Z","tags":null},"/notes/Two-Pointers":{"title":"Algorithm - Two Pointers","content":"\n**투포인터 알고리즘(Two Pointers Algorithm)** 또는 **슬라이딩 윈도우(Sliding Window)** 라고 부른다.\n\n알고리즘 문제를 풀다 완전탐색으로 해결하면 시간 초과가 나는 문제가 종종 있는데, 이때 사용하면 빠르게 해결할 수 있다. 기본적인 원리는 다음과 같다.\n\n\u003e 1차원 배열이 있고, 이 배열에서 각자 다른 원소를 가리키고 있는 2개의 포인터를 조작해가면서 원하는 것을 얻기\n\nN칸의 1차원 배열이 있을 때, 부분 배열 중 그 원소의 합이 M이 되는 경우의 수를 구한다고 생각해보자. 모든 경우의 수를 다 테스트 해보면 구간 합을 구간 배열로 `O(1)`만에 구한다고 해도 경우의 수는 `O(N^2)`이 된다. 따라서 문제를 풀 수 없다. N의 최대 범위가 너무 크기 때문이다. 그러나 이 경우 각 원소는 자연수이고 M 또한 자연수인데, 따라서 다음과 같이 풀 수 있다.\n\n- 포인터 2개를 준비한다. 시작과 끝을 알 수 있도록 start, end 라고 한다.\n- 맨 처음에는 start = end = 0이며, 항상 start\u003c=end을 만족해야 한다.\n- 2개의 포인터는 현재 부분 배열의 시작과 끝을 가리키는 역할을 한다.\n\ns=e일 경우 그건 크기가 0인, 아무것도 포함하지 않는 부분 배열을 뜻한다. 다음의 과정을 s \u003c N인 동안 반복한다.\n\n1. 만약 현재 부분합이 M 이상이거나, 이미 e = N이면 s++\n2. 그렇지 않다면 e++\n3. 현재 부분합이 M과 같으면 결과 ++ \n\n쉽게 이해하자면, start와 end 를 무조건 증가시키는 방향으로만 변화시켜가면서 도중에 부분 배열의 합이 정확히 M이 되는 경우를 세는 것이다. \n\nEx) M = 5인 경우를 살펴보자.\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_56/kks227_1471976777631dvMpe_PNG/1.png?type=w2)\n\n초기 상태이며, 빨간색 포인터 : start, 파란색 포인터 : end이다. S : 합.\n\n**end**가 뒤로 움직일 때는 새로 포함한 원소를 S에 더하고, **start**가 뒤로 움직일 때는 새로 넘긴 원소를 S에서 빼는 식으로 현재 [start, end)의 합 S를 매번 쉽게 구할 수 있다.\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_196/kks227_1471976777962Qks67_PNG/2.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_274/kks227_1471976778508STsIS_PNG/3.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_118/kks227_1471976778842HkF4H_PNG/4.png?type=w2)\n\n처음에는 이렇게 end만 증가하게 된다. S가 계속 M보다 작기 때문! 마지막엔 S\u003e=M이 되었으므로 아래와 같다.\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_101/kks227_1471976779156aosTT_PNG/5.png?type=w2)\n\nstart를 한 칸 옮겼는데, 동시에 S = 5인 경우를 만났다. 이때 결과를 1 증가시켜 준다.\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_186/kks227_1471976779456z8WVP_PNG/6.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_1/kks227_1471976779887ko5yw_PNG/7.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_265/kks227_1471976780291PDw0Y_PNG/8.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_139/kks227_1471976780603hkxD5_PNG/9.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_284/kks227_1471976780877YjQiA_PNG/10.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_101/kks227_1471976781212P3Li0_PNG/11.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_188/kks227_14719767815252r1eQ_PNG/12.png?type=w2)\n\n이런 식으로 포인터들이 움직이게 된다. 여기서 2번째로 S = 5인 지점을 만났으므로 결과를 1 증가시켜 준다.\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_80/kks227_14719767817475h0eo_PNG/13.png?type=w2)\n\n그 직후, start가 1 증가하면서 start = end인 경우가 나온다.\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_240/kks227_1471976782107sRHbv_PNG/14.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_240/kks227_14719767826459iErQ_PNG/15.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_192/kks227_1471976782977RS8E6_PNG/16.png?type=w2)\n\n계속 가다 보면 세 번째로 S = 5인 지점을 만난다.\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_147/kks227_1471976783270H1Bah_PNG/17.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_44/kks227_1471976783607C4F3g_PNG/18.png?type=w2)\n\n그 이후 조건에 맞춰 포인터를 증가시키다 보면, end가 배열 끝을 가리키게 되어 더이상 증가할 수 없는 상태가 된다.\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_197/kks227_1471976784071FLqRR_PNG/19.png?type=w2)\n\n![img](https://mblogthumb-phinf.pstatic.net/20160824_87/kks227_14719767845214em80_PNG/20.png?type=w2)\n\n그렇게 되면 그냥 start만 증가시켜 가다가 start 역시 배열 끝에 다다르면 종료해도 되고, 그냥 그 자리에서 루프를 끝내버려도 된다. 이렇게 해서 S = 5인 경우는 3개 발견되었다.\n\n- 시간 복잡도 \n  - 이 알고리즘은 매 루프마다 항상 두 포인터 중 하나는 1씩 증가하고 있고, 각 포인터가 N번 누적 증가해야 알고리즘이 끝난다. 따라서 각각 배열 끝에 다다르는데 `O(N)`이라서 합쳐도 `O(N)`이 된다.\n\n- **추천 문제(백준 기준)**\n  - 2003 : 수들의 합\n  - 1644 : 소수의 연속합\n  - 1806 : 부분합\n  - 2230 : 수 고르기\n  - 1484 : 다이어트\n  - 2038 : 골룽 수열\n  - 2531 : 회전 초밥\n  - 2096 : 내려가기\n  - 2293 : 동전1\n\n---\n### Reference\n- https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Algorithm/투포인터%20알고리즘.md\n","lastmodified":"2022-10-13T09:10:42.007571978Z","tags":null},"/notes/coding-test":{"title":"👩‍💻 Coding Test","content":"\n## 프로그래머스 문제 모음\n\n### Level 1\n- [숫자 문자열과 영단어](notes/숫자%20문자열과%20영단어.md)\n- [키패드 누르기](notes/키패드%20누르기.md)\n\n### Level 2\n- [기능개발](notes/기능개발.md)\n- [올바른 괄호](notes/올바른%20괄호.md)\n- [다음 큰 숫자](notes/다음%20큰%20숫자.md)\n- [영어 끝말잇기](notes/영어%20끝말잇기.md)\n- [구명보트](notes/구명보트.md)\n- [멀리뛰기](notes/멀리뛰기.md)\n","lastmodified":"2022-10-13T09:10:42.007571978Z","tags":null},"/notes/paper-review":{"title":"📑 Paper Review","content":"\n## Contents\n\n- [📄 GLUCOSE](notes/GLUCOSE.md)\n- [📄 On Cross-Dataset Generalization in Automatic Detection of Online Abuse](notes/On%20Cross-Dataset%20Generalization%20in%20Automatic%20Detection%20of%20Online%20Abuse.md) \n- [📄 Towards generalisable hate speech detection](notes/Towards%20generalisable%20hate%20speech%20detection.md)\n- [📄 Call for Customized Conversation: Customized Conversation Grounding Persona and Knowledge](notes/Call%20for%20Customized%20Conversation.md)\n","lastmodified":"2022-10-13T09:10:42.01157202Z","tags":null}}